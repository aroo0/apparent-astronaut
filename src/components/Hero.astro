---
import Wave from './Wave.astro'
import CarotDown from '../assets/icons/PhCaretDownLight.svg'

---
<section class="hero noise" id="hero">
    <canvas id="canvas" ></canvas>
    <div class="container">
    <span class="hello ">Hello, I am</span>
    <h2 class="name">Arek Dec.</h2>
    <hr class="" />
    <span class="devo ">A Frontend Developer based in Cracow, Poland. </span>
    <span class="description ">Deeply passionate about creating immersive UI that captivate users and stays current with new design trends.</span>
  </div>

  <a href="#about">
    <div class="button-down">      
    <img src={CarotDown.src} alt="caret down" width="30" height="30" class="caret"/>
  </a>
  </div>
  <div class="svg-container">
    <Wave />

  </div>
  </section>


  <script defer>
    // Get the SVG element and the hero element
    const svgElement = document.querySelector('.responsive-svg');
    const heroElement = document.querySelector('.hero');

    // Update the height of the hero element based on the SVG's current height
    function updateHeroHeight() {
        const svgHeight = svgElement.getBoundingClientRect().height;
        heroElement.style.minHeight = `calc(100vh + ${svgHeight}px)`;
        }

    // Call the updateHeroHeight function initially and on window resize
    updateHeroHeight();

    window.addEventListener('resize', updateHeroHeight);

    const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')

canvas.width = window.innerWidth
canvas.height = window.innerHeight

// Define the region for ball movement
let regionWidth = canvas.width * 0.9;
let regionHeight = canvas.height;
let regionX = (canvas.width - regionWidth) / 2;
let regionY = (canvas.height - regionHeight) / 2;

window.addEventListener('resize', function() {

  canvas.width = window.innerWidth
  canvas.height = window.innerHeight
  regionWidth = canvas.width;
  regionHeight = canvas.height;
  regionX = (canvas.width - regionWidth) / 2;
  regionY = (canvas.height - regionHeight) / 2;
  balls = []

    generateBalls(regionX, regionY, regionWidth, regionHeight);




})

let balls = [];
const mouse = {
    x: null,
    y: null

}
canvas.addEventListener('mousemove', function(event) {
    mouse.x = event.x
    mouse.y = event.y

})


// Ball class
class Ball {
  constructor(x, y, dx, dy, radiusX, radiusY, rotation, endAngle,  color, strokeColor) {
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this.radiusX = radiusX;
    this.radiusY = radiusY
    this.rotation = rotation
    this.endAngle = endAngle
    this.color = color;
    this.strokeColor = strokeColor
    this.deceleration = 0.001; // Deceleration factor for slowing down over time
    this.minDistance = 350; // Minimum distance between ball and mouse cursor

  }

  // Update ball position
  update() {
    const dxMouse = mouse.x - this.x;
    const dyMouse = mouse.y - this.y;
    const distanceMouse = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);

    // Check for collision with mouse cursor
    if (distanceMouse < this.minDistance) {
        // Calculate new velocities to move ball away from mouse cursor
        const angle = Math.atan2(dyMouse, dxMouse);
        const targetX = this.x - Math.cos(angle) * this.minDistance;
        const targetY = this.y - Math.sin(angle) * this.minDistance;
        this.dx = (targetX - this.x) * 0.01; // Adjust velocity for smoother movement
        this.dy = (targetY - this.y) * 0.01; // Adjust velocity for smoother movement
    }

    this.x += this.dx;
    this.y += this.dy;

    // Apply deceleration to velocities
    this.dx *= (1 - this.deceleration);
    this.dy *= (1 - this.deceleration);

// Check for collision with canvas edges
if (this.x + this.radiusX > regionX + regionWidth) {
  this.x = regionX + regionWidth - this.radiusX; // Set ball just inside right edge
  this.dx = -Math.abs(this.dx); // Invert velocity to move away from right edge
} else if (this.x - this.radiusX < regionX) {
  this.x = regionX + this.radiusX; // Set ball just inside left edge
  this.dx = Math.abs(this.dx); // Invert velocity to move away from left edge
}

if (this.y + this.radiusY > regionY + regionHeight) {
  this.y = regionY + regionHeight - this.radiusY; // Set ball just inside bottom edge
  this.dy = -Math.abs(this.dy); // Invert velocity to move away from bottom edge
} else if (this.y - this.radiusY < regionY) {
  this.y = regionY + this.radiusY; // Set ball just inside top edge
  this.dy = Math.abs(this.dy); // Invert velocity to move away from top edge
}
    // Draw ball
    ctx.beginPath();
    ctx.ellipse(this.x, this.y , this.radiusX , this.radiusY, this.rotation, 0, this.endAngle);
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.strokeColor;
    ctx.lineWidth = 50;
    ctx.stroke()
    ctx.fill();
    ctx.closePath();

  }
}

function generateBalls(regionX, regionY, regionWidth, regionHeight) {
  const ballSets = [
    [
      { radiusX: 60, radiusY: 120, rotation: 15, color: 'rgba(175, 91, 91, 0.33)', strokeColor: 'rgba(175, 91, 91, 0.33)', count: 12, maxSpeed: 1 },
      { radiusX: 60, radiusY: 120, rotation: 20, color: 'rgba(16, 45, 49, 1)', strokeColor: 'rgba(14, 21, 22, 0.6)', count: 14, maxSpeed: 1 },
      { radiusX: 50, radiusY: 120, rotation: 30, color: 'rgba(48, 83, 136, 1)', strokeColor: 'rgba(48, 83, 136, 0.49)', count: 14, maxSpeed: 1 },
      { radiusX: 60, radiusY: 125, rotation: 10, color: 'rgba(111, 63, 112, 1)', strokeColor: 'rgba(111, 63, 112, 0.49)', count: 14, maxSpeed: 1 },
      { radiusX: 70, radiusY: 120, rotation: 40, color: 'rgba(12, 71, 71, .8)', strokeColor: 'rgba(12, 71, 71, .6)', count: 18, maxSpeed: 1 },
      { radiusX: 60, radiusY: 120, rotation: 30, color: 'rgba(220, 66, 121, .5)', strokeColor: 'rgba(80, 29, 52, .5)', count: 18, maxSpeed: 1 }
    ]
  ];

  ballSets.forEach((ballSet) => {
    ballSet.forEach((params) => {
      for (let i = 0; i < params.count; i++) {
        const x = regionX + Math.random() * regionWidth;
        const y = regionY + Math.random() * regionHeight;
        const dx = Math.random() * params.maxSpeed;
        const dy = Math.random() * params.maxSpeed;
        const endAngle = Math.PI * 2;
        balls.push(new Ball(x, y, dx, dy, params.radiusX, params.radiusY, params.rotation, endAngle, params.color, params.strokeColor));
      }
    });
  });
}


// Animation loop
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // Update and draw balls
  balls.forEach(ball => {
    ball.update();
  });
  
  requestAnimationFrame(animate);
}
  generateBalls(regionX, regionY, regionWidth, regionHeight);
  animate();



  </script>

  <style>
    /* Hero section */

    /* Hero Gradient */

canvas {
    width: 80%;
    height: 110%;
    top: 50%; /* Position the element 50% from the top of the container */
    left: 50%; /* Position the element 50% from the left of the container */
    transform: translate(-50%, -50%); 
    position: absolute;
    background-color: #302130;
    /* animation: changeBgColor 3s ease-in-out infinite alternate;

    background-image:
    linear-gradient(90deg, #0a0f0fa4 3%, transparent 30%),
    linear-gradient(90deg, transparent 50%, #152020 100%),
    radial-gradient(at 11% 94%, hsla(289,24%,36%,1) 0px, transparent 50%),
    radial-gradient(at 0% 0%, hsla(175,11%,20%,1) 0px, transparent 50%),
    radial-gradient(at 36% 60%, hsla(322,45%,41%,1) 0px, transparent 50%),
    radial-gradient(at 91% 94%, hsla(173,60%,11%,1) 0px, transparent 50%),
    radial-gradient(at 79% 27%, hsla(234,44%,36%,1) 0px, transparent 50%); */

}


.hero {
    background-color: #152020;
    position: relative;
    overflow: hidden;

    &::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='4.97' numOctaves='1' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        pointer-events: none;
        opacity: 0.8;
        z-index: 0;
        mix-blend-mode: soft-light;
        filter: brightness(80%);
    }

    & .container {
        padding-top: 13rem;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: clamp(1rem, 3vh, 3rem);
        filter: hue-rotate(50deg);
        z-index: 3;


    }
    

    & .hello {
        font-size: clamp(0.9rem, 4vw, 2rem);
        color: var(--dark-gray-color);
        transition-delay: 100ms;

    }

    & .name {
        font-family: var(--sec-font);
        font-weight: 400;
        font-size: clamp(2.1rem, 10vw, 5.6rem);
        color: var(--main-light-color);
        line-height: 0.8;
        transition-delay: 200ms;
    }

    & .devo {
        font-size: clamp(1rem, 6vw, 2rem);
        color: var(--main-light-color);
        transition-delay: 400ms;

    }

    & .description {
        font-size: clamp(0.9rem, 4vw, 1.6rem);
        color: var(--sec-light-color);
        font-weight: 300;
        line-height: 1.5;
        max-width: 60ch;
        transition-delay: 500ms;

    }

    & hr {
        border: none; /* Remove default hr border */
        border-top: 2px solid var(--sec-light-color);
        max-width: 50rem;
        transition-delay: 200ms;
        

    }

}

.svg-container {
    position: absolute;
    bottom: -1px;
    width: 100%; /* Make the SVG container span the entire width */
    overflow: hidden; /* Hide any overflow from the SVG */
    z-index: 3;
  }

.button-down {
    border: 1px solid var(--dark-gray-color);
    padding: .9rem .4rem;
    border-radius: 1rem;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 88vh;
    transition: var(--hover-transition);

    &:hover {
        filter: brightness(110%);

    }
}
  </style>